<?php
/**
 * Contain Project
 *
 * This source file is subject to the BSD license bundled with
 * this package in the LICENSE.txt file. It is also available
 * on the world-wide-web at http://www.opensource.org/licenses/bsd-license.php.
 * If you are unable to receive a copy of the license or have 
 * questions concerning the terms, please send an email to
 * me@andrewkandels.com.
 *
 * @category    akandels
 * @package     contain
 * @author      Andrew Kandels (me@andrewkandels.com)
 * @copyright   Copyright (c) 2012 Andrew P. Kandels (http://andrewkandels.com)
 * @license     http://www.opensource.org/licenses/bsd-license.php BSD License
 * @link        http://andrewkandels.com/contain
 */

namespace Contain\Entity;

use Contain\Exception\InvalidArgumentException;
use Traversable;
use Zend\EventManager\EventManager;
use Zend\EventManager\Event;
use Iterator;

/**
 * User Entity (auto-generated by the Contain module)
 *
 * This instance should not be edited directly. Edit the definition file instead 
 * and recompile.
 */
class User implements \Iterator
{
    /** @var Contain\Entity\Property\Type\DateTimeType */
    protected $createdAt;

    /** @var Contain\Entity\Property\Type\DateTimeType */
    protected $updatedAt;

    /** @var Contain\Entity\Property\Type\IntegerType */
    protected $id;

    /** @var Contain\Entity\Property\Type\StringType */
    protected $name;

    /** @var Contain\Entity\Property\Type\EnumType */
    protected $status;

    /** @var array */
    protected $_types = array();

    /** @var integer */
    protected $_iterator = 0;

    /** @var Zend\EventManager\EventManager */
    protected $_eventManager;

    /** @var array */
    protected $_extendedProperties = array();

    /**
     * Constructor
     *
     * @param   array|Traversable               Properties
     * @return  $this
     */
    public function __construct($properties = null)
    {
        $this->_types['createdAt'] = new \Contain\Entity\Property\Type\DateTimeType();
        $this->_types['updatedAt'] = new \Contain\Entity\Property\Type\DateTimeType();
        $this->_types['id'] = new \Contain\Entity\Property\Type\IntegerType();
        $this->_types['name'] = new \Contain\Entity\Property\Type\StringType();
        $this->_types['status'] = new \Contain\Entity\Property\Type\EnumType();
        $this->_types['status']->unserialize("[\"active\",\"inactive\"]");

        if ($properties) {
            $this->fromArray($properties);
        }
    }

    /**
     * Called when the User entity has been initialized. Commonly used to register
     * event hooks.
     *
     * @return  $this
     */
    protected function init()
    {
        $this->getEventManager()->attach('property.get', function (Event $e) {
            $property = $e->getParam('property');
            if ($property['name'] == 'name') {
                $property['name'] = 'loser';
                $e->setParam('property', $property);
            }
        });

        $this->getEventManager()->attach('insert.pre', function (Event $e) {
            $entity = $e->getTarget();
            $now    = new DateTime('now');
            $entity->setCreatedAt($now)
                   ->setUpdatedAt($now);
        });

        $this->getEventManager()->attach('update.pre', function (Event $e) {
            $entity = $e->getTarget();
            $now    = new DateTime('now');
            $entity->setUpdatedAt($now);
        });
    }

    /**
     * Retrieves an instance of the Zend Framework event manager in order to 
     * register or trigger events.
     *
     * @return  Zend\EventManager\EventManager
     */
    public function getEventManager()
    {
        if (!$this->_eventManager) {
            $this->_eventManager = new EventManager();
        }

        return $this->_eventManager;
    }

    /**
     * Retrieves an instance of the Zend Framework event manager in order to 
     * register or trigger events.
     *
     * @param   Zend\EventManager\EventManager
     * @return  $this
     */
    public function setEventManager(EventManager $eventManager)
    {
        $this->_eventManager = $eventManager;
        return $this;
    }

    /**
     * 'property.get' event that is fired when a property is accessed.
     *
     * @param   string              Property name
     * @param   mixed               Current Value
     * @param   boolean             Is the value presently set
     * @return  mixed|null
     */
    public function onEventGetter($property, $currentValue, $isValueSet)
    {
        $eventManager = $this->getEventManager();
        $argv = $eventManager->prepareArgs(array('property' => array(
            'name'          => $property,
            'currentValue'  => $currentValue,
            'isSet'         => $isValueSet,
        )));
        $this->getEventManager()->trigger('property.get', $this, $argv);

        if (isset($argv['property']['value'])) {
            return $argv['property']['value'];
        }

        return $currentValue;
    }

    /**
     * 'property.set' event when a property is being set.
     *
     * @param   string              Property name
     * @param   mixed               Current Value
     * @param   mixed               New Value
     * @param   boolean             Is the value presently set
     * @return  mixed|null
     */
    public function onEventSetter($property, $currentValue, $newValue, $isValueSet)
    {
        $eventManager = $this->getEventManager();
        $argv = $eventManager->prepareArgs(array('property' => array(
            'property'      => $property,
            'currentValue'  => $currentValue,
            'isSet'         => $isValueSet,
            'value'         => $newValue,
        )));
        $this->getEventManager()->trigger('property.set', $this, $argv);

        return $argv['property']['value'];
    }

    /**
     * Fetches an extended property which can be set at anytime.
     *
     * @param   string                  Extended property name
     * @return  mixed
     */
    public function getExtendedProperty($name)
    {
        return $this->onEventGetter(
            $name, 
            isset($this->_extendedProperties[$name]) ? $this->_extendedProperties[$name] : null,
            isset($this->_extendedProperties[$name])
        );
    }

    /**
     * Injects an extended property which can be set at anytime.
     *
     * @param   string                  Extended property name
     * @param   mixed                   Value to set
     * @return  $this
     */
    public function setExtendedProperty($name, $value)
    {
        $this->_extendedProperties[$name] = $this->onEventSetter(
            $name, 
            isset($this->_extendedProperties[$name]) ? $this->_extendedProperties[$name] : null,
            $value,
            isset($this->_extendedProperties[$name])
        );

        return $this;
    }

    /**
     * Gets an array of all the entity's properties.
     *
     * @param   boolean             Include extended properties
     * @return  array
     */
    public function getProperties($includeExtended = false)
    {
        $result = array();
        if ($this->hasCreatedAt()) {
            $result[] = 'createdAt';
        }
        if ($this->hasUpdatedAt()) {
            $result[] = 'updatedAt';
        }
        if ($this->hasId()) {
            $result[] = 'id';
        }
        if ($this->hasName()) {
            $result[] = 'name';
        }
        if ($this->hasStatus()) {
            $result[] = 'status';
        }

        if ($includeExtended) {
            foreach ($this->_extendedProperties as $key => $value) {
                if (!in_array($key, $result)) {
                    $result[] = $key;
                }
            }
        }

        return $result;
    }

    /**
     * Returns an array of all the entity properties (including extended properties).
     *
     * @param   boolean             Include extended properties
     * @return  array
     */
    public function toArray($includeExtended = false)
    {
        $properties = $this->getProperties();
        $result     = array();

        foreach ($properties as $property) {
            $method = 'get' . ucfirst($property);
            $value = $this->$method();
            if ($this->_types[$property]->getUnsetValue() !== $value) {
                $result[$property] = $value;
            }
        }

        if ($includeExtended) {
            foreach ($this->_extendedProperties as $key => $value) {
                if (!isset($result[$key])) {
                    $result[$key] = $value;
                }
            }
        }

        return $result;
    }

    /**
     * Hydrates entity properties from an array.
     *
     * @param   array               Property key/value pairs
     * @param   boolean             Use extended properties for any undefined index
     * @return  $this
     */
    public function fromArray($properties, $allowExtended = false)
    {
        if (!is_array($properties) && !$properties instanceof Traversable) {
            throw new InvalidArgumentException('$properties must be an array or an instance of Traversable.');
        }

        foreach ($properties as $key => $value) {
            switch ($key) {
                case 'createdAt':
                    $this->setCreatedAt($value);
                    break;

                case 'updatedAt':
                    $this->setUpdatedAt($value);
                    break;

                case 'id':
                    $this->setId($value);
                    break;

                case 'name':
                    $this->setName($value);
                    break;

                case 'status':
                    $this->setStatus($value);
                    break;

                default:
                    if ($allowExtended) {
                        $this->_extendedProperties[$key] = $value;
                        return $this;
                    }
                    throw new InvalidArgumentException("'$key' is not a valid property of the User entity.");
                    break;
            }
        }

        return $this;
    }

    /**
     * Getter for the createdAt property.
     *
     * @return  datetime
     */
    public function getCreatedAt()
    {
        return $this->onEventGetter(
            'createdAt', 
            $this->createdAt,
            $this->_types['createdAt']->getUnsetValue() !== $this->createdAt
        );
    }

    /**
     * Setter for the createdAt property.
     *
     * @param   datetime      Value to set
     * @return  $this
     */
    public function setCreatedAt($value)
    {
        $value = $this->onEventSetter(
            'createdAt',
            $this->createdAt,
            $value,
            $this->_types['createdAt']->getUnsetValue() !== $this->createdAt
        );
        $this->createdAt = $this->_types['createdAt']->parse($value);
        return $this;
    }

    /**
     * Returns true if the createdAt property has been set/hydrated.
     *
     * @return  boolean
     */
    public function hasCreatedAt()
    {
        return $this->_types['createdAt']->getUnsetValue() !== $this->createdAt;
    }

    /**
     * Getter for the updatedAt property.
     *
     * @return  datetime
     */
    public function getUpdatedAt()
    {
        return $this->onEventGetter(
            'updatedAt', 
            $this->updatedAt,
            $this->_types['updatedAt']->getUnsetValue() !== $this->updatedAt
        );
    }

    /**
     * Setter for the updatedAt property.
     *
     * @param   datetime      Value to set
     * @return  $this
     */
    public function setUpdatedAt($value)
    {
        $value = $this->onEventSetter(
            'updatedAt',
            $this->updatedAt,
            $value,
            $this->_types['updatedAt']->getUnsetValue() !== $this->updatedAt
        );
        $this->updatedAt = $this->_types['updatedAt']->parse($value);
        return $this;
    }

    /**
     * Returns true if the updatedAt property has been set/hydrated.
     *
     * @return  boolean
     */
    public function hasUpdatedAt()
    {
        return $this->_types['updatedAt']->getUnsetValue() !== $this->updatedAt;
    }

    /**
     * Getter for the id property.
     *
     * @return  integer
     */
    public function getId()
    {
        return $this->onEventGetter(
            'id', 
            $this->id,
            $this->_types['id']->getUnsetValue() !== $this->id
        );
    }

    /**
     * Setter for the id property.
     *
     * @param   integer      Value to set
     * @return  $this
     */
    public function setId($value)
    {
        $value = $this->onEventSetter(
            'id',
            $this->id,
            $value,
            $this->_types['id']->getUnsetValue() !== $this->id
        );
        $this->id = $this->_types['id']->parse($value);
        return $this;
    }

    /**
     * Returns true if the id property has been set/hydrated.
     *
     * @return  boolean
     */
    public function hasId()
    {
        return $this->_types['id']->getUnsetValue() !== $this->id;
    }

    /**
     * Getter for the name property.
     *
     * @return  string
     */
    public function getName()
    {
        return $this->onEventGetter(
            'name', 
            $this->name,
            $this->_types['name']->getUnsetValue() !== $this->name
        );
    }

    /**
     * Setter for the name property.
     *
     * @param   string      Value to set
     * @return  $this
     */
    public function setName($value)
    {
        $value = $this->onEventSetter(
            'name',
            $this->name,
            $value,
            $this->_types['name']->getUnsetValue() !== $this->name
        );
        $this->name = $this->_types['name']->parse($value);
        return $this;
    }

    /**
     * Returns true if the name property has been set/hydrated.
     *
     * @return  boolean
     */
    public function hasName()
    {
        return $this->_types['name']->getUnsetValue() !== $this->name;
    }

    /**
     * Getter for the status property.
     *
     * @return  enum
     */
    public function getStatus()
    {
        return $this->onEventGetter(
            'status', 
            $this->status,
            $this->_types['status']->getUnsetValue() !== $this->status
        );
    }

    /**
     * Setter for the status property.
     *
     * @param   enum      Value to set
     * @return  $this
     */
    public function setStatus($value)
    {
        $value = $this->onEventSetter(
            'status',
            $this->status,
            $value,
            $this->_types['status']->getUnsetValue() !== $this->status
        );
        $this->status = $this->_types['status']->parse($value);
        return $this;
    }

    /**
     * Returns true if the status property has been set/hydrated.
     *
     * @return  boolean
     */
    public function hasStatus()
    {
        return $this->_types['status']->getUnsetValue() !== $this->status;
    }

    /**
     * Rewinds the internal position counter (iterator).
     *
     * @return  void
     */
    public function rewind()
    {
        $this->_iterator = 0;
    }

    /**
     * Returns the property of the current iterator position.
     *
     * @return  Contain\Entity\Property
     */
    public function current()
    {
        $properties = $this->getProperties();
        $getter     = 'get' . ucfirst($properties[$this->_iterator]);
        return $this->$getter();
    }

    /**
     * Returns the current iterator property position.
     *
     * @return  integer
     */
    public function key()
    {
        $properties = $this->getProperties();
        return $properties[$this->_iterator];
    }

    /**
     * Advances the iterator to the next property.
     *
     * @return  void
     */
    public function next()
    {
        $this->_iterator++;
    }

    /**
     * Is the iterator in a valid position.
     *
     * @return  boolean
     */
    public function valid()
    {
        $properties = $this->getProperties();
        return isset($properties[$this->_iterator]);
    }

    /**
     * Some shit
     */
    public function getPrettyName()
    {
        return ucfirst($this->getName());
    }

    public function getLastUpdate()
    {
        return 'whenever';
    }

}